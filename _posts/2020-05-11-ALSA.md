---
layout: post
title:  "ALSA를 이용하여 Linux에서 음원 재생해보기"
date:   2020-05-11
comments: true
excerpt: "ALSA Introduction"
categories: ALSA 
tag:
- c
- multimedia 
- ALSA 
---

# 이걸 하게 된 이유 
pulseaudio의 구조를 분석하면서 들었던 의문 중 하나는 pulseaudio client를 통해 server로 전달된 음원 data가 어떻게 스피커로 전달되어 재생이 되는지였다. pulseaudio에서는 pulseaduio server가 client로 부터 음원데이터를 모아 mixing 하고 이를 현재 장치와 관련 있는 module에 전달함으로서 이루어진다. 그러면 실제로 취합된 data를 어떻게 스피커로 전달하는가? 라는 의문에 대한 대답은 module을 분석함으로써 얻을 수 밖에 없다. module은 pulseaudio에 추가 기능을 지원해 주기 위해 만들어진 object인데, 만약 bluetooth장치를 통해서 재생을 하고 싶다면 bluetooth module에, 유선 장치를 통해 재생을 하고 싶다면 ALSA module을 이용하여 재생을 하게 된다. 

다시 원점으로 돌아가서, 그렇다면 위의 의문인 음원 data가 어떻게 스피커로 전달되는지, 정확히 얘기하면 "유선 스피커"로 어떻게 전달되는지를 알고 싶다면, ALSA가 어떻게 동작하는지를 파악 할 수 밖에 없다. 때문에 이번 post에서는 ALSA를 이용하여 간단한 음원 재생 코드를 분석해보고, 각 재생코드의 함수를 하나하나 뜯어가면서 실제 음원이 어떻게 재생되는 지를 알아보고자 한다.

해당 코드는 이 [링크](http://equalarea.com/paul/alsa-audio.html) 에서 참고 했다.

# Audio application은 대충 어떻게 생겼나

```c
open_the_device();
set_the_parameters_of_the_device();
while (!done) {
  /* one or both of these */
  receive_audio_data_from_the_device();
  deliver_audio_data_to_the_device();
}
close the device
```

# A Minimal Playback Program
#include <stdio.h>
#include <stdlib.h>
#include <alsa/asoundlib.h>

```c
main (int argc, char *argv[]) {
  int i;
  int err;
  short buf[128];
  snd_pcm_t *playback_handle;
  snd_pcm_hw_params_t *hw_params;

  if ((err = snd_pcm_open (&playback_handle, argv[1], SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
    fprintf (stderr, "cannot open audio device %s (%s)\n", 
        argv[1],
        snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_malloc (&hw_params)) < 0) {
    fprintf (stderr, "cannot allocate hardware parameter structure (%s)\n",
        snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_any (playback_handle, hw_params)) < 0) {
    fprintf (stderr, "cannot initialize hardware parameter structure (%s)\n",
        snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_access (playback_handle, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED)) < 0) {
    fprintf (stderr, "cannot set access type (%s)\n",
        snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_format (playback_handle, hw_params, SND_PCM_FORMAT_S16_LE)) < 0) {
    fprintf (stderr, "cannot set sample format (%s)\n",
        snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_rate_near (playback_handle, hw_params, 44100, 0)) < 0) {
    fprintf (stderr, "cannot set sample rate (%s)\n",
        snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_channels (playback_handle, hw_params, 2)) < 0) {
    fprintf (stderr, "cannot set channel count (%s)\n",
        snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params (playback_handle, hw_params)) < 0) {
    fprintf (stderr, "cannot set parameters (%s)\n",
        snd_strerror (err));
    exit (1);
  }

  snd_pcm_hw_params_free (hw_params);

  if ((err = snd_pcm_prepare (playback_handle)) < 0) {
    fprintf (stderr, "cannot prepare audio interface for use (%s)\n",
        snd_strerror (err));
    exit (1);
  }

  for (i = 0; i < 10; ++i) {
    if ((err = snd_pcm_writei (playback_handle, buf, 128)) != 128) {
      fprintf (stderr, "write to audio interface failed (%s)\n",
          snd_strerror (err));
      exit (1);
    }
  }

  snd_pcm_close (playback_handle);
  exit (0);
}
```
