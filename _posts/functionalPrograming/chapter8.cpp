//함수형 자료 구조
//복사에 효울적인 자료 구조에 대해서 다뤄보자

//불변 연결 리스트

// 리스트의 시작 부분에 요소 추가와 삭제
// 새로운 요소를 만들어서 리스트의 앞에 추가 

/*
                                                     +-------+       +-------+        +-------+
                                                     |       |       |       |        |       |
                        original List (Root) +-----> |   A   | +---> |   B   | +----> |   C   |
                                                     |       |       |       |        |       |
                                         +---------> +-------+       +-------+        +-------+
                             +--------+  |                                         
                             |        |  |                             
New List (Root)  +---------> |   E    |  +
                             |        |
                             +--------+                             

// 리스트 요소 삭제                             
                                                     +-------+       +-------+        +-------+
                                                     |       |       |       |        |       |
                        original List (Root) +-----> |   A   | +---> |   B   | +----> |   C   |
                                                     |       |       |       |        |       |
                                                     +-------+       +---^---+        +-------+
                                                                         |
                                                                         |
                                                                         |
New List (Root)+---------------------------------------------------------+

*/

// 데이터의 복사도 필요없고 실행시간 면에서도 효율적이다

// 리스트의 끝부분에 요소 추가와 삭제
// 이 경우에는 어쩔 수 없이 복사를 해야 한다
// 리스트 중간에서 요소 추가와 삭제는 적당한 복사를 통해 해결해야한다

/*
| O(1)                  | O(n)                 |
|-----------------------|----------------------|
| 첫 번째 요소 가져오기 | 추가하기             |
| 앞쪽에 요소 추가하기  | 연결하기             |
| 첫 번째 요소 삭제하기 | 특정 지점에 삽입하기 |
|                       | 마지막 요소 가져오기 |
|                       | n번째 요소 가져오기  |
*/
 
// 메모리 관리
// std::shared_ptr를 사용하면 깔끔하게 메모리 관리가 가능하다
template <typename T>
class list {
  public:
    ...
  private:
    struct node {
      T value;
      std::shared_ptr<node> tail;
    };

    std::shared_ptr<node> m_head;
}

// 문제점 만약 이 shared_ptr chain이 길어진다면 스택 오버플로가 나타날 수 있다
// 재귀적 구조체 소멸 없애기
// swap해서 free 시킴

~node() {
  auto next_node = std::move(tail);
  while (next_node) {
    if(!next_node.unique()) break;

    std::shared_ptr<node> tail;
    swap(tail, next_node->tail);
    next_node.reset();

    next_node = std::move(tail);
  }
}

// 벡터 유사 가변 자료 구조

// 아무래도 linked list보다는 std::vector를 자주 사용하게 된다
// std::vector를 그냥 쓰게되면 새로운 항목을 추가할 때마다 복사가 필요 (인덱싱)
// 이를 줄이기 위해서 비트맵 벡터를 사용하자 (벡터의 벡터)
// m의 length를 가진 std::vector를 가지고 이걸 tree의 형태로 만들어서 사용하자
// 이렇게 될 경우 중간에 새로운 요소를 추가하거나 고치면 이 index가 포함된 vector만 고쳐서 link된 bitmap vector를 새로 만듦면된다
// | O(1)                 | O(n)                 |
// |----------------------|----------------------|
// | 인덱스 요소 접근하기 | 앞에 추가하기        |
// | 요소 추가하기        | 연결하기             |
// |                      | 특정 지점에 삽입하기 | 


// 벡터 유사 가변 자료 구조의 장점은 기존 vector에 비해서 복사가 더 효율적이라는 것 뿐이다
// 그밖에 요소 접근과 같은 부분에서는 오히려 캐시 미스의 발생확률이 높을 수 있다 
